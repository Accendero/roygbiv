<!DOCTYPE html>
<html lang="en">
  <head>
    <title>three.js webgl - loaders - vtk loader</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
      body {
        font-family: Monospace;
        background-color: #000;
        color: #fff;
        margin: 0px;
        overflow: hidden;
      }
      #info {
        color: #fff;
        position: absolute;
        top: 10px;
        width: 100%;
        text-align: center;
        z-index: 100;
        display:block;
      }
      #info a, .button { color: #f00; font-weight: bold; text-decoration: underline; cursor: pointer }
    </style>
  </head>

  <body>

    <script src="three.js/build/three.min.js"></script>

    <script src="three.js/examples/js/controls/TrackballControls.js"></script>

    <script src="three.js/examples/js/loaders/VTKLoader.js"></script>
    
    <script src="three.js/examples/js/Detector.js"></script>
    <script src="three.js/examples/js/libs/stats.min.js"></script>
    <script src="http://code.jquery.com/jquery-2.1.4.min.js"></script>

    <script>

      if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

      var container, stats;

      var camera, controls, scene, renderer;

      var cross;
      
      var objects = [];
      

      init();
      animate();

      function init() {

        camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.01, 1e10 );
        camera.position.z = 20.2;
        
        controls = new THREE.TrackballControls( camera );

        controls.rotateSpeed = 5.0;
        controls.zoomSpeed = 5;
        controls.panSpeed = 2;

        controls.noZoom = false;
        controls.noPan = false;

        controls.staticMoving = true;
        controls.dynamicDampingFactor = 0.3;

        scene = new THREE.Scene();

        scene.add( camera );

        // light

        var dirLight = new THREE.DirectionalLight( 0xffffff );
        dirLight.position.set( 200, 200, 1000 ).normalize();

        camera.add( dirLight );
        camera.add( dirLight.target );

        var material = new THREE.MeshLambertMaterial( { color:0xffffff, side: THREE.DoubleSide } );

        var loader = new THREE.VTKLoader();

        loader.load( "ohbmdemo/threeview/lh.pial.vtk", function ( geometry ) {

          geometry.computeVertexNormals();
		  
          var mesh = new THREE.Mesh( geometry, material );
          mesh.position.setY( - 0.09 );
          scene.add( mesh );
          console.log("line 97")
          console.log(geometry)

        } );

        // renderer

        renderer = new THREE.WebGLRenderer( { antialias: false } );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );

        container = document.createElement( 'div' );
        document.body.appendChild( container );
        container.appendChild( renderer.domElement );

        stats = new Stats();
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.top = '0px';
        container.appendChild( stats.domElement );

        //

        window.addEventListener( 'resize', onWindowResize, false );

      }

      function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

        controls.handleResize();

      }

      function animate() {

        requestAnimationFrame( animate );

        controls.update();
        renderer.render( scene, camera );

        stats.update();

      }

    </script>

    <script>
	    
	    	Number.prototype.clamp = function(min, max) {
				  return Math.min(Math.max(this, min), max);
				};

            var getColor = function (inputval, offset)
            {
                 var fourValue = 4 * (inputval/offset);
                 var red   = Math.min(fourValue - 1.5, -fourValue + 4.5);
                 var green = Math.min(fourValue - 0.5, -fourValue + 3.5);
                 var blue  = Math.min(fourValue + 0.5, -fourValue + 2.5);

                return [ red.clamp(0,1), green.clamp(0,1), blue.clamp(0,1)];

            };

            function loadbestLabel(){

                $.get('bestlabel.csv', function(data){

                    if(data){
                        $(bestLabel).empty()
                    }
                    bestLabel = data.split('\n');
                    console.log(bestLabel)
                })
            }

            function loadbestvalue(){

                $.get('bestvalue.csv', function(data){

                    if(data){
                        $(bestValue).empty()
                    }
                    bestValue = data.split('\n');
                })
            }


            function loadLabelShapes(){
                $.get('label_shapes_noheader.csv', function(data){
                    if(data){
                        $(mapParams).empty();
                    }
                    var lines = data.split('\r');
                    $(lines).each(function(line, val){
//                        console.log(val.split(',').length);
                        mapParams.push(val.split(','));
                    });

                    console.log('labels loaded')
                })
            }

            function loadVertexMap(){

                $.get('vertexlabels.csv', function(data){

                    if(data){
                        $(mapParams).empty();
                    }

                    var lines = data.split('\r');

                    vertexmap = data.split('\r');

//                    $(lines).each(function(line, val){
////                        console.log(val.split(',').length);
//                        mapParams.push(val.split(','));
//                    });

                    console.log('vertex labels loaded')
                })
            }
            
            var loadFile = function(csvfile, baseval)
            
            {

//                var objtoremove = objects[0];
//                    scene.remove(objtoremove);

//                var loader = new THREE.VTKLoader();
				
				//loader.load( "lh.pial.vtk" );
				//console.log("line 273")
				//loader.load("data/mindboggled/Twins-2-1/labels/left_cortical_surface/freesurfer_cortex_labels.vtk")
				//loader.load( "data/mindboggled/Twins-2-1/labels/left_cortical_surface/freesurfer_cortex_labels.vtk", function ( geometry ) {

				          geometry.computeVertexNormals();
						  var material = new THREE.MeshLambertMaterial( { color:0xffffff, side: THREE.DoubleSide } );
				          var mesh = new THREE.Mesh( geometry, material );
				          mesh.position.setY( - 0.09 );
				          scene.add( mesh );
				          
				        $.get(csvfile, function(data){
	
						console.log("line 285")
	
	                    var arraydat = data.split('\r')
	                    var color;
						console.log("line 245")
						console.log(geometry)
						
	                    for ( var i = 0; i < geometry.faces.length; i++ )
	                    {
	                        face = geometry.faces[ i ];
	                        var faceIndices = ['a', 'b', 'c', 'd'];
	
	                        // determine if face is a tri or a quad
	                        var numberOfSides = ( face instanceof THREE.Face3 ) ? 3 : 4;

	                        // assign color to each vertex of current face
	                        for( var j = 0; j < numberOfSides; j++ )
	                        {
		                        //console.log("line 259")
	                            color = new THREE.Color( 0xffffff );
	                            //console.log("line 261")
	                            //console.log(arraydat[i])
	                            var carray = getColor(arraydat[i], baseval)
	                            //console.log(carray)
	                            color.setRGB(carray[0], carray[1], carray[2]);
	                            face.vertexColors[ j ] = color;
	                            face.color = color;
	                        }
	                    }
						console.log("line 262")
	                    geometry.dynamic  = true;
	                    geometry.dirty = true;
	                    geometry.needsUpdate = true;
	
		                cubeMaterial = new THREE.MeshBasicMaterial(
	                    { color: 0xffffff, shading: THREE.FlatShading,
	                    vertexColors: THREE.VertexColors } );
                    
	                    var mesh = new THREE.Mesh( geometry, cubeMaterial );
	                    mesh.castShadow = true;
	                    
	                    
	                    sphereMaterial =
                  new THREE.MeshLambertMaterial(
                    {
                      color: 0xFF4DDE,
                      transparent: true,
                      opacity: 0.0
                    });
					
					
					var radius = 8,
	                segments = 16,
	                rings = 16;
	
	            // create a new mesh with
	            // sphere geometry - we will cover
	            // the sphereMaterial next!
	                sphere = new THREE.Mesh(
	
	                  new THREE.SphereGeometry(
	                    radius,
	                    segments,
	                    rings),
	
	                  sphereMaterial);
	
	                

					
					//scene = new THREE.Scene();
	                    
	                    scene.add(sphere);
	                    
	                    
	                    sphere.material.opacity = 0.0;
	
					    scene.add( mesh );
	                    objects.push(mesh);
                     });
				          
				
				        } );
            }

    </script>
    
    
    
    <script>
	//MAIN    
	    
	    loadFile("data/mindboggled/Twins-2-1/xtra/tables/curvature-neg-250.csv", 10)
	    //loadFile("data/mindboggled/Twins-2-1/xtra/tables/travel-3000.csv", 10)
	    //loadFile("data/mindboggled/Twins-2-1/xtra/tables/vertexlabels.csv", 10)
	    
	    
	    
    </script>
    
  </body>
</html>
