<!DOCTYPE html>
<html lang="en">
  <head>
    <title>three.js webgl - loaders - vtk loader</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
      body {
        font-family: Monospace;
        background-color: #000;
        color: #fff;
        margin: 0px;
        overflow: hidden;
      }
      #info {
        color: #fff;
        position: absolute;
        top: 10px;
        width: 100%;
        text-align: center;
        z-index: 100;
        display:block;
      }
      #info a, .button { color: #f00; font-weight: bold; text-decoration: underline; cursor: pointer }
    </style>
  </head>

  <body>

    <script src="three.js/build/three.min.js"></script>

    <script src="three.js/examples/js/controls/TrackballControls.js"></script>

    <script src="three.js/examples/js/loaders/VTKLoader.js"></script>
    
    <script src="three.js/examples/js/Detector.js"></script>
    <script src="three.js/examples/js/libs/stats.min.js"></script>
    <script src="http://code.jquery.com/jquery-2.1.4.min.js"></script>
    <script src="scripts/utils.js"></script>

    <script>



      if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

      var container, stats;

      var camera, controls, scene, renderer;

      var cross;
      
      var objects = [];
      


var init = function() {

        camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.01, 1e10 );
        camera.position.z = 20.2;
        
        controls = new THREE.TrackballControls( camera );

        controls.rotateSpeed = 5.0;
        controls.zoomSpeed = 5;
        controls.panSpeed = 2;

        controls.noZoom = false;
        controls.noPan = false;

        controls.staticMoving = true;
        controls.dynamicDampingFactor = 0.3;

        scene = new THREE.Scene();

        scene.add( camera );

        // light

        var dirLight = new THREE.DirectionalLight( 0xffffff );
        dirLight.position.set( 200, 200, 1000 ).normalize();

        camera.add( dirLight );
        camera.add( dirLight.target );

        var material = new THREE.MeshLambertMaterial( { color:0xffffff, side: THREE.DoubleSide } );

        var loader = new THREE.VTKLoader();

        /*loader.load( "data/mindboggled/Twins-2-1/labels/left_cortical_surface/freesurfer_cortex_labels.vtk", function ( geometry ) {
				
		  
          geometry.computeVertexNormals();
          
          
        console.log("faces",geometry.faces)

          var mesh = new THREE.Mesh( geometry, material );
          mesh.geometry.computeFaceNormals()
/*
          for ( var i = 0; i < mesh.geometry.faces.length; i ++ ) {
//          for ( var i = 0; i < 1000; i ++ ) {
              var face = mesh.geometry.faces[i];
              face.color.setHex( Math.random() * 0xffffff );
              face.color.setRGB( Math.random(), Math.random(), Math.random());
         }
         


//          var mesh = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors } );


          mesh.position.setY( - 0.09 );
          scene.add( mesh );
          console.log("line 97")
          console.log(geometry)
          

        } );*/
        
        function loadMesh(name) {
			var oReq = new XMLHttpRequest();
			oReq.open("GET", name, true);
			oReq.onload = function(oEvent) {
				var buffergeometry=new THREE.VTKLoader().parse(this.response);
				geometry=new THREE.Geometry().fromBufferGeometry(buffergeometry);
				geometry.computeFaceNormals();
				geometry.computeVertexNormals();
				geometry.__dirtyColors = true;
						
				material=new THREE.MeshLambertMaterial({vertexColors: THREE.FaceColors});
				var color = [Math.random(), Math.random(), Math.random()]
					    
				for (i=0;i<geometry.faces.length;i++){
					var face = geometry.faces[i];
					face.color.setHex( Math.random() * 0xffffff );
					face.color.setRGB(color[0],color[1],color[2]);
					
					//face.materials = [ new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff } ) ];
				}
				geometry.colorsNeedUpdate = true
				mesh=new THREE.Mesh(geometry,material);
				mesh.dynamic=true
				
				console.log(mesh)
				scene.add(mesh);
				
			}
			oReq.send();
		}
		
		//loadMesh("data/mindboggled/Twins-2-1/labels/left_cortical_surface/freesurfer_cortex_labels.vtk")
		
				$.ajax({dataType: "json",
		       url:"files_to_load.json",
		       data:function(data){},
		       success:function(data,textStatus,jqXHR){
			       console.log(data)
			       N = Object.keys(data["filename"])
			       console.log(N)
			       for (i=0;i<N.length;i++){
				       loadMesh(data["filename"][i])
				       //loadMesh("data/mindboggled/Twins-2-1/labels/left_cortical_surface/freesurfer_cortex_labels.vtk")
				       console.log("added mesh",i)
				       console.log(data["filename"][i])
				       //break
			       }  
		       }})
		
		//console.log(mesh.geometry.faces)
		        
               // renderer

        renderer = new THREE.WebGLRenderer( { antialias: false } );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );

        container = document.createElement( 'div' );
        document.body.appendChild( container );
        container.appendChild( renderer.domElement );

        stats = new Stats();
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.top = '0px';
        container.appendChild( stats.domElement );

        window.addEventListener( 'resize', onWindowResize, false );
        
        }


      init();
      animate();



 


      

      function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

        controls.handleResize();

      }

      function animate() {

        requestAnimationFrame( animate );

        controls.update();
        renderer.render( scene, camera );

        stats.update();

      }

    </script>

    <script>
	                
            var loadFile = function(csvfile, baseval)
            
            {


//                var loader = new THREE.VTKLoader();
				
				//loader.load( "lh.pial.vtk" );
				//console.log("line 273")
				//loader.load("data/mindboggled/Twins-2-1/labels/left_cortical_surface/freesurfer_cortex_labels.vtk")
				//loader.load( "data/mindboggled/Twins-2-1/labels/left_cortical_surface/freesurfer_cortex_labels.vtk", function ( geometry ) {

				          //geometry.computeVertexNormals();
						  var material = new THREE.MeshLambertMaterial( { color:0xffffff, side: THREE.DoubleSide } );
				          var mesh = new THREE.Mesh( geometry, material );
				          mesh.position.setY( - 0.09 );
				          scene.add( mesh );
				          
				        $.get(csvfile, function(data){
	
						console.log("line 285")
	
	                    var arraydat = data.split('\r')
	                    var color;
						console.log("line 245")
						//console.log(geometry)
						
	                    for ( var i = 0; i < geometry.faces.length; i++ )
	                    {
	                        face = geometry.faces[ i ];
	                        var faceIndices = ['a', 'b', 'c', 'd'];
	
	                        // determine if face is a tri or a quad
	                        var numberOfSides = ( face instanceof THREE.Face3 ) ? 3 : 4;

	                        // assign color to each vertex of current face
	                        for( var j = 0; j < numberOfSides; j++ )
	                        {
		                        //console.log("line 259")
	                            color = new THREE.Color( 0xffffff );
	                            //console.log("line 261")
	                            //console.log(arraydat[i])
	                            var carray = getColor(arraydat[i], baseval)
	                            //console.log(carray)
	                            color.setRGB(carray[0], carray[1], carray[2]);
	                            face.vertexColors[ j ] = color;
	                            face.color = color;
	                        }
	                    }
						console.log("line 262")
	                    geometry.dynamic  = true;
	                    geometry.dirty = true;
	                    geometry.needsUpdate = true;
	
		                cubeMaterial = new THREE.MeshBasicMaterial(
	                    { color: 0xffffff, shading: THREE.FlatShading,
	                    vertexColors: THREE.VertexColors } );
                    
	                    var mesh = new THREE.Mesh( geometry, cubeMaterial );
	                    mesh.castShadow = true;
	                    
	                    
	                    sphereMaterial =
                  new THREE.MeshLambertMaterial(
                    {
                      color: 0xFF4DDE,
                      transparent: true,
                      opacity: 0.0
                    });
					
					
					var radius = 8,
	                segments = 16,
	                rings = 16;
	
	            // create a new mesh with
	            // sphere geometry - we will cover
	            // the sphereMaterial next!
	                sphere = new THREE.Mesh(
	
	                  new THREE.SphereGeometry(
	                    radius,
	                    segments,
	                    rings),
	
	                  sphereMaterial);
	
	                

					
					//scene = new THREE.Scene();
	                    
	                    scene.add(sphere);
	                    
	                    
	                    sphere.material.opacity = 0.0;
	
					    scene.add( mesh );
	                    objects.push(mesh);
                     });
				          
				
				        } ;
            

    </script>
    
    
    
    <script>
	//MAIN    
	    
	    //loadFile("data/mindboggled/Twins-2-1/xtra/tables/curvature-neg-250.csv", 10)
	    //loadFile("data/mindboggled/Twins-2-1/xtra/tables/travel-3000.csv", 10)
	    //loadFile("data/mindboggled/Twins-2-1/xtra/tables/vertexlabels.csv", 10)
	    
	    
	    
    </script>
    
  </body>
</html>
